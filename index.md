---
title: Welcome to my blog
---
# 贪心
## [135. 分发糖果](https://leetcode.cn/problems/candy/)

### 题解


相邻孩子评分更高的孩子获得更多的糖果等价于 `孩子评分比左边高则大于左边，比右边高则大于右边 ` 

分两步满足该条件，首先处理孩子评分比左边高的情况，处理这个情况需要从左向右遍历，因为单独处理该孩子时，处理手段是让孩子的糖果数量为左孩子的糖果数+1，这要求左孩子的糖果数是靠谱的，也即左孩子也满足 `孩子评分比左边高则大于左边`，从左往右第一个孩子是自动满足的，接着让之后的孩子也满足即可，这样局部都得到保留，从而全局达成条件 `孩子评分比左边高则大于左边` ；试想一下如果从右往左会怎么样，会出现持续对初始值+1并赋值的操作，则新的操作可能会让旧操作失效，即破坏了局部（比如评分从小到大排序的情况）。第二步类似，但注意不要破坏第一步达成的条件，即在调整+1的时候仅在本身就小于右边时才执行，不能轻易调小。



## [435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)

给定一个区间的集合 intervals ，其中 `intervals[i] = [starti, endi]` 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。

### 题解

取所有区间的最小边界和最大边界，组成一个区间，那么我们要做的就等价于每次选一个端点区间保留，且尽可能保留更多相对方向的区域，也即尽可能使更多的区间保留。需要注意的是，以左端点非递减排序的时候必须从最后开始保留，左端点最大，保留它可以为左边预留更多的空间，左端点最小不一定右端点也小。



## [605. 种花问题](https://leetcode.cn/problems/can-place-flowers/)

### 题解



策略同上题，尽可能给剩余部分留更多的空间，得以种更多的花。具体解法有两种，假设背靠花，和假设背靠空地，往前推进计算即可，其中后者更方便，因为初始状态就满足背靠空地的条件。



## [452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

### 题解

用最少数量的箭等价于一箭引爆最多的气球，类似题目435 无重叠区间。贪心策略为解决一个气球时尽可能多的找到可以同时被引爆的气球，排序后，可以确保一个气球没有start比它更大的，那么只有其余气球的end大于等于start才能引爆，因为需要引爆所有的气球，这一箭是必须且引爆最多的，那么就能达到最终使用最少数量的箭。



## [763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)

### 题解

划分尽可能多的区间等价于让每个区间尽可能小，取区间内所有字母最小边界为左边界，最大边界为右边界即可。按序遍历，我们就只需要考虑右边界即可。



## [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

### 题解

在股票比购入时小的时候就在购入到这个时候之前的范围内选大于等于购入时的价格中最大的一天抛出。默认购入第一天的股票。

有一个较好的技巧是，只要比前一天价格高就在前一天购买并在后一天抛出。如果持续上升等价于在上升的第一天买入，上升最后一天抛出

![img](https://pic.leetcode-cn.com/274e94b876be62bbefbc76890d63d5881031d2d247037348b072ba6841220147-Picture7.png)

## [406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

贪心策略为一次仅满足一个人的位置需求，只需要让后来的不破坏先前构建的位置关系即可。先满足最高的人的位置需求，后来的人无论放在哪都不会破坏位置关系，因为没有比最高的人更高的人了，如果高度相同就先满足前面人少的需求，因为相同高度的人在后的一定是前面人数更多的，先插入前面人数少的才能满足前面人数多的。



## [665. 非递减数列](https://leetcode.cn/problems/non-decreasing-array/)

遇到递减情况时改变局部，满足非递减需求。通过对比三个相邻的数来完成。



# 排序

## [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。

使用快速选择法，通过定位枢轴可以知道是第几大的元素，不断二分选择即可。



# 动态规划

## [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

先考虑能否由子问题的解组合出最后问题的解，假如我们知道每一段的最长子序列长度，此时新增一个数，需要考虑是否存在更长的子序列，我们需要与某个子序列的尾部进行比较才能得出结果，所以设计状态：以该数字结尾的最长子序列长度。在已计算的状态中寻找满足条件且最长的长度加一作为新的状态即可。

## [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

最多可以完成k笔交易，则我们需要考虑增加一个交易次数的维度来限制。

设`sell[i][j]`为在`i`个`price`中卖出 j 次的最大收入

假定状态以后，尝试用子问题解决新问题：

```
sell[i][j] = max(sell[i - 1][j], buy[i][j] + prices[i - 1]);
```

这里允许当天买当天卖来凑次数

可以发现我们还需要假定一个状态`buy[i][j]`为在`i`个`price`中购入`j`次的最大收入。同样，尝试更新新状态：

```
buy[i][j] = max(buy[i - 1][j], sell[i - 1][j - 1] - prices[i -1]);
```

两个数组的维度为n + 1，k + 1，方便处理初边界情况。

初始化时须将`buy[0]`的每个元素设为`-prices[0]`这是因为第一天的时候计算购买多少次时会与`buy[0]`比较，而第一天是必须要购买的，所以将`buy[0][j]`设定为购买了j次和出售了j - 1次 (j > 0)

之所以允许当天买当天卖是因为其他天买卖的情况下并不一定交易了k次后就是最大利润，所以如果不计算当天买卖的次数，`buy[i][j]`状态的含义可以解释为在`i`天内最多买入 j 次下的最大收入

由以上可以压缩状态为

```
buy[j] = max(buy[j], sell[j-1] - prices[i]);
```

```
sell[j] = max(sell[j], buy[j] + prices[i]);
```

